---
title: 期望_高斯消元_博弈_题解
date: 2019-08-15 23:38:36
tags:
	- 算法
	- 数论
	- 博弈
	- 期望
	- 高斯消元
	- 题解
categories:
	- 题解
cover:  static/images/algorithm/Snakes-and-Ladders.png
---

公式不显示的话请刷新一次！！！

## Snakes and Ladders( 概率dp+高斯消元)

#### 题意：

玩一个叫做‘**Snakes and Ladder**’类似于大富翁的游戏，有10*10​ 的100个格子从1~100编号，从1号格子开始走，每次投骰子走1~6格，有一些格子会发生单向传送，从a传送到b，1和100不会发生传送，一个格子也不会有两种传送。给出一系列传送的a和b，求从1走到100的期望次数。

![Snakes-and-Ladders](/static/images/algorithm/Snakes-and-Ladders.png)

#### 题解：

用 $dp[i]$ 表示从格子 $i$ 走出去的期望次数。$next[i]$ 表示从 $i$ 传送到 $next[i]$.

分两种情况考虑：

格子可以传送：$dp[i]=dp[next[i]]$

格子不可以传送：$dp\left[ i \right] =\frac{1}{6}\cdot \varSigma _{j=1}^{k}dp\left[ i+j \right] +\frac{1}{6}\cdot \varSigma _{j=k+1}^{6}dp\left[ i \right] +1\left( i+k=\text{100,}j<=6 \right)$  化简得：$k\cdot dp\left[ i \right] -\varSigma _{j=1}^{k}dp\left[ i+j \right] =6$

因为传送是无序的，所以不能用递推，得列矩阵方程用高斯消元解

#### 代码：

```c++
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const double eps = 1e-6;
const int N = 110;
int nxt[N];
double a[N][N];
int  gauss(int n,int m){
    int col,i,mxr,j,row;
    for(row=col=1;row<=n&&col<=m;row++,col++){
        mxr = row;
        for(i=row+1;i<=n;i++)
            if(fabs(a[i][col])>fabs(a[mxr][col]))
                mxr = i;
        if(mxr != row) swap(a[row],a[mxr]);
        if(fabs(a[row][col]) < eps){
            row--;
            continue;
        }
        for(i=1;i<=n;i++)///消成上三角矩阵
            if(i!=row&&fabs(a[i][col])>eps)
                for(j=m;j>=col;j--)
                    a[i][j]-=a[row][j]/a[row][col]*a[i][col];
    }
    row--;
    for(int i = row;i>=1;i--){///回代成对角矩阵
        for(int j = i + 1;j <= row;j++){
                a[i][m] -= a[j][m] * a[i][j];
        }
        a[i][m] /= a[i][i];
    }
    return row;
}
int main()
{
    int T, cas = 1;
    cin>>T;
    while(T--){
        int n;
        scanf("%d",&n);
        memset(nxt, 0, sizeof(nxt));
        for(int i = 0;i < n;i++){
            int x , y;
            scanf("%d%d",&x,&y);
            nxt[x] = y;
        }
        printf("Case %d: ",cas++);
        memset(a, 0, sizeof(a));
        for(int i = 1;i < 100;i++){
            if(nxt[i]){
                a[i][101] = 0;
                a[i][i] = 1,a[i][nxt[i]] = -1;
            }else{
                int cnt = 0;
                for(int j = 1;i + j <= 100 && j <= 6;j++){
                    cnt++;
                    a[i][i+j] = -1;
                }
                a[i][i] = cnt,a[i][101] = 6;
            }
        }
        a[100][100] = 1,a[100][101] = 0;
        int row = gauss(100,101);
        printf("%.12lf\n",a[1][101]);
    }
    return 0;
}
```



## 治疗之雨（期望dp+高斯消元）

#### 题意：

有 $1+m$ 个数 $\left\{ p\text{，}\infty ,\infty ,...,\infty \right\}$ ，其中 $0\le p\le n$ 

对其进行多轮操作，每轮操作如下：

* 在不为最大值的数中等概率随机选择一个（如果没有则不操作），把它+1，每轮本操作进行1次。
* 在不为最小值的数中等概率随机选择一个（如果没有则不操作），把它 -1，每轮本操作进行k次。

问期望进行多少轮操作以后第一个数会变为最小值0 ?

#### 题解：

设 $A_i$ 为每轮第一个数被减 $i$ 次的概率：$A_i=C_{k}^{i}\cdot \left( \frac{1}{m+1} \right) ^i\cdot \left( \frac{m}{m+1} \right) ^{k-i}$

设 $F_i$ 为当前第一个数为 $i$ ,将其变成 0 的期望步数，容易得出：

$$
F_i=1+\frac{1}{m+1}\underset{j=0}{\overset{i}{\varSigma}}A_jF_{i+1-j}+\frac{m}{m+1}\underset{j=0}{\overset{i-1}{\varSigma}}A_jF_{i-j}
$$

还得考虑 $i=n$ 的情况，这个时候第一个数不会进行加操作,最后得出：
$$
F_i=\left\{ \begin{array}{l}
	1+\frac{1}{m+1}\underset{j=0}{\overset{i}{\varSigma}}A_jF_{i+1-j}+\frac{m}{m+1}\underset{j=0}{\overset{i-1}{\varSigma}}A_jF_{i-j} \ \ ,\ i<n\\
	1+\underset{j=0}{\overset{i-1}{\varSigma}}A_jF_{i-j}\ \ ,\ i=n\\
\end{array} \right.
$$
然后考虑概率期望的通常做法：高斯消元

由于 $n=1500$，高斯消元显然会TLE

然后我们观察一下这个方程组，发现矩阵长下面这样，所以考虑消元成下三角矩阵,然后解出 $F_n$ ，递推出答案就好了，那么复杂度就可以优化到$O(n^2)$ 了。
$$
\left[ \begin{matrix}{}
	X&		0&		0&		0&		0&		0&		0&		0&		0\\
	X&		X&		X&		0&		0&		0&		0&		0&		0\\
	X&		X&		X&		X&		0&		0&		0&		0&		0\\
	X&		X&		X&		X&		X&		0&		0&		0&		0\\
	.&		.&		.&		.&		.&		.&		0&		0&		0\\
	.&		.&		.&		.&		.&		.&		.&		0&		0\\
	.&		.&		.&		.&		.&		.&		.&		.&		0\\
	X&		X&		X&		X&		X&		X&		X&		X&		X\\
	X&		X&		X&		X&		X&		X&		X&		X&		X\\
\end{matrix} \right]
$$


#### 代码：

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>
using namespace std;
void read(int &x) {
    char ch; bool ok;
    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;
    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;
}
#define rg register
const int maxn=1.5e3+10,mod=1e9+7;
int n,T,m,p,k,a[maxn][maxn],fac[maxn],inv[maxn],A[maxn],facc[maxn];
int mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}
int mi(int a,int b)
{
    int ans=1;
    while(b)
    {
        if(b&1)ans=1ll*ans*a%mod;
        b>>=1,a=1ll*a*a%mod;
    }
    return ans;
}
void prepare()
{
    fac[0]=inv[0]=1;
    for(rg int i=1;i<=1500;i++)fac[i]=1ll*fac[i-1]*i%mod;
    inv[1500]=mi(fac[1500],mod-2);;
    for(rg int i=1499;i;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;
}
int C(int x,int y)
{
    int ans=1;
    if(y<=1500)ans=1ll*ans*fac[y]*inv[y-x]%mod;
    else ans=1ll*ans*facc[x]%mod;
    return 1ll*ans*inv[x]%mod;
}
void gauss()
{
    int y[maxn];
    for(rg int i=1;i<=n;i++)
    {
        for(rg int j=1;j<i;j++)
        {
            int t=1ll*a[i][j]*y[j]%mod;
            a[i][j+1]=(a[i][j+1]-mul(t,a[j][j+1])+mod)%mod;
            a[i][j]=0,a[i][n+1]=(a[i][n+1]-mul(t,a[j][n+1])+mod)%mod;
        }
        y[i]=mi(a[i][i],mod-2);
    }
    int ans=mul(a[n][n+1],y[n]);
    for(rg int i=n-1;i>=p;i--)ans=1ll*(a[i][n+1]-mul(a[i][i+1],ans)+mod)%mod*y[i]%mod;
    printf("%d\n",ans?(ans+mod)%mod:-1);
}
int main()
{
    read(T),prepare();
    while(T--)
    {
        memset(a,0,sizeof a);
        read(n),read(p),read(m),read(k);int res=0;
        if(!k||(!m&&k==1)){puts("-1");continue;}
        if(!m)
        {
            while(p>0){if(p<n)++p;p-=k,++res;}
            printf("%d\n",res),res=0;continue;
        }
        for(rg int i=1;i<=n;i++)a[i][i]=a[i][n+1]=mod-1;
        int ny=mi(m+1,mod-2),u=mul(ny,m);memset(A,0,sizeof A);facc[0]=1;
        if(k>1500)for(rg int i=1;i<=n;i++)facc[i]=mul(facc[i-1],(k-i+1));
        for(rg int i=0;i<=min(k,n);i++)A[i]=mul(C(i,k),mul(mi(ny,i),mi(u,k-i)));
        for(rg int i=1;i<n;i++)
        {
            for(rg int j=0;j<=i;j++)a[i][i+1-j]=(a[i][i+1-j]+mul(ny,A[j]))%mod;
            for(rg int j=0;j<i;j++)a[i][i-j]=(a[i][i-j]+mul(u,A[j]))%mod;
        }
        for(rg int i=0;i<n;i++)a[n][n-i]=(a[n][n-i]+A[i])%mod;
        gauss();
    }
}
```



## BE, GE or NE 2018ICPC徐州站网络赛(博弈+dp)

#### 题意：

有两个人博弈：
有n次选择，每次选择只能有一个人选择其中一个。两人轮流选择。
给出一个初始分数m，对于每次给出的选择有三种选项，a,b,c

a.如果a>0,表示可以选择，并且使当前值+a

b.如果b>0,表示可以选择，并且使当前值-b

c.如果c=1，表示可以选择，并且使当前值取相反数

问最后结果，如果最后结果x >=k,则“Good Ending”，如果x<=l，则“Bad Ending”，介于两值之间，则“Normal Ending”

#### 题解：

由初始分数m计算出双方最优策略操作后最后的分数，太难。我们可以倒着想，在双方最优策略下，看看初始分数m可以由最后哪个分数得出来，这样就简单多了。

设 $d[i][j]$ 表示第 $i$ 次操作时，当前分数为 $j$ ，在双方最优策略后最后分数为 $d[i][j]$ 。

可以知道，$d[n+1][j]$ 肯定等于 $j$，那么怎么倒推求 $d[i][j]$ ？

当a，b，c都不为0时，如果 i 为奇数，代表我来选择，我肯定是想最后分数越来越高，那么 $d[i][j]=max(d[i][j+a]，d[i][j-b]，d[i][-j])$，表示我有这三种选择，哪种选择最后的分越高，我就选哪个，i 为偶数，就取最小，由于数组下标不能为负数，以及这题上下界为-100到100，因此这题要把区间换成0到200，注意倒推的时候，加法别超过200，减法别小于0。

#### 代码：

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=1005;
int a[maxn],b[maxn],c[maxn],d[maxn][205];
int main()
{
	int n,m,k,l,t;
	while(~scanf("%d%d%d%d",&n,&m,&k,&l))
	{
		k+=100,l+=100,m+=100;//-100到100的区间换成0到200 
		for(int i=1;i<=n;i++)
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
		for(int i=0;i<=200;i++)d[n+1][i]=i;
		for(int i=n;i;i--)
		for(int j=0;j<=200;j++) 
		{
			int res1=0,res2=200;
			if(a[i])
			{
				t=min(200,j+a[i]);
				res1=max(res1,d[i+1][t]);
				res2=min(res2,d[i+1][t]);
			}
			if(b[i])
			{
				t=max(0,j-b[i]);
				res1=max(res1,d[i+1][t]);
				res2=min(res2,d[i+1][t]);
			}
			if(c[i])
			{
				t=200-j;
				res1=max(res1,d[i+1][t]);
				res2=min(res2,d[i+1][t]);
			}
			if(i&1) d[i][j]=res1;
			else d[i][j]=res2;
		}
		if(d[1][m]>=k)puts("Good Ending");
		else if(d[1][m]<=l)puts("Bad Ending");
		else puts("Normal Ending");
	}
}
```



## Adrien and Austin 2018ICPC区域赛南京站 (博弈)

#### 题意：

有一堆数量为$N$的石子，石子编号从$1⋯N$排成一列，两个人玩游戏，每次可以取$1⋯K$个连续编号的石子，Adrien先手，如果有谁不能取了则输，两个人为Adrien 和Austin

#### 题解：

当K为1时显然的和N的奇偶性有关，那么我们考虑一下$K>1$的情况
对于先手的Adrien来说，他对任意的N颗石子，他都可以将这N颗石子分成两段相当数量的石子(从中间开始拿对于奇数拿一颗，对于偶数拿两颗)，那么剩下的两段相当于是独立的两个相同的游戏了，如果后手拿其中一段，那么我先手就对另一段进行这样相同的拆分，那么能保证我先手总是有石子能拿，所以我先手必胜，也就是说当 $K>1$的时候先手必胜，$K==1$的时候判断奇偶，$N==0$的时候特判即可

#### 代码：

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <math.h>
#include <stack>
#include <list>
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    if(n==0)
    {
        printf("Austin\n");
    }
    else if(k==1)
    {
        if(n%2==1)
            printf("Adrien\n");
        else
            printf("Austin\n");
    }
    else
        printf("Adrien\n");
    return 0;
}
```

